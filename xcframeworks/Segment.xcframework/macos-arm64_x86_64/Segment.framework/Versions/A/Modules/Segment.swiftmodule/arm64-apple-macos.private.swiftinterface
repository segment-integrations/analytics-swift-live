// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.9.10 clang-1600.0.26.2)
// swift-module-flags: -target arm64-apple-macos10.15 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name Segment
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Darwin.C
import Cocoa
import Darwin
import Foundation
import JSONSafeEncoding
import Sovran
import Swift
import SystemConfiguration
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public class Analytics {
  public static var debugLogsEnabled: Swift.Bool
  public var timeline: Segment.Timeline
  public static func shared() -> Segment.Analytics
  public init(configuration: Segment.Configuration)
  @objc deinit
  public func process(event: any Segment.RawEvent)
}
extension Segment.Analytics {
  public var enabled: Swift.Bool {
    get
    set(value)
  }
  public var writeKey: Swift.String {
    get
  }
  public var anonymousId: Swift.String {
    get
  }
  public var userId: Swift.String? {
    get
  }
  public var operatingMode: Segment.OperatingMode {
    get
  }
  public var flushInterval: Foundation.TimeInterval {
    get
    set(value)
  }
  public var flushAt: Swift.Int {
    get
    set(value)
  }
  public var flushPolicies: [any Segment.FlushPolicy] {
    get
  }
  public func traits<T>() -> T? where T : Swift.Decodable, T : Swift.Encodable
  public func traits() -> [Swift.String : Any]?
  public func flush(completion: (() -> Swift.Void)? = nil)
  public func reset()
  public func version() -> Swift.String
  public static func version() -> Swift.String
}
extension Segment.Analytics {
  public func settings() -> Segment.Settings?
  public func manuallyEnableDestination(plugin: any Segment.DestinationPlugin)
}
extension Segment.Analytics {
  public var hasUnsentEvents: Swift.Bool {
    get
  }
  public var pendingUploads: [Foundation.URL]? {
    get
  }
  public func purgeStorage()
  public func purgeStorage(fileURL: Foundation.URL)
  public func waitUntilStarted()
}
extension Segment.Analytics {
  public func openURL<T>(_ url: Foundation.URL, options: T? = nil) where T : Swift.Decodable, T : Swift.Encodable
  public func openURL(_ url: Foundation.URL, options: [Swift.String : Any] = [:])
}
public protocol AnonymousIdGenerator : AnyObject, Swift.Decodable, Swift.Encodable {
  func newAnonymousId() -> Swift.String
}
public enum OperatingMode {
  case synchronous
  case asynchronous
  public static func == (a: Segment.OperatingMode, b: Segment.OperatingMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum StorageMode {
  case disk
  case diskAtURL(Foundation.URL)
  case memory(Swift.Int)
  case custom(any Segment.DataStore)
}
public class Configuration {
  public init(writeKey: Swift.String)
  @objc deinit
}
extension Segment.Configuration {
  @discardableResult
  public func application(_ value: Any?) -> Segment.Configuration
  @discardableResult
  public func trackApplicationLifecycleEvents(_ enabled: Swift.Bool) -> Segment.Configuration
  @discardableResult
  public func flushAt(_ count: Swift.Int) -> Segment.Configuration
  @discardableResult
  public func flushInterval(_ interval: Foundation.TimeInterval) -> Segment.Configuration
  @discardableResult
  public func defaultSettings(_ settings: Segment.Settings?) -> Segment.Configuration
  @discardableResult
  public func autoAddSegmentDestination(_ value: Swift.Bool) -> Segment.Configuration
  @discardableResult
  public func apiHost(_ value: Swift.String) -> Segment.Configuration
  @discardableResult
  public func cdnHost(_ value: Swift.String) -> Segment.Configuration
  @discardableResult
  public func requestFactory(_ value: @escaping (Foundation.URLRequest) -> Foundation.URLRequest) -> Segment.Configuration
  @discardableResult
  public func errorHandler(_ value: @escaping (any Swift.Error) -> Swift.Void) -> Segment.Configuration
  @discardableResult
  public func flushPolicies(_ policies: [any Segment.FlushPolicy]) -> Segment.Configuration
  @discardableResult
  public func operatingMode(_ mode: Segment.OperatingMode) -> Segment.Configuration
  @discardableResult
  public func flushQueue(_ queue: Dispatch.DispatchQueue) -> Segment.Configuration
  @discardableResult
  public func userAgent(_ userAgent: Swift.String) -> Segment.Configuration
  @discardableResult
  public func jsonNonConformingNumberStrategy(_ strategy: JSONSafeEncoding.JSONSafeEncoder.NonConformingFloatEncodingStrategy) -> Segment.Configuration
  @discardableResult
  public func storageMode(_ mode: Segment.StorageMode) -> Segment.Configuration
  @discardableResult
  public func anonymousIdGenerator(_ generator: any Segment.AnonymousIdGenerator) -> Segment.Configuration
  @discardableResult
  public func httpSession(_ httpSession: @autoclosure @escaping () -> any Segment.HTTPSession) -> Segment.Configuration
}
public enum AnalyticsError : Swift.Error {
  case storageUnableToCreate(Swift.String)
  case storageUnableToWrite(Swift.String)
  case storageUnableToRename(Swift.String)
  case storageUnableToOpen(Swift.String)
  case storageUnableToClose(Swift.String)
  case storageInvalid(Swift.String)
  case storageUnknown(any Swift.Error)
  case networkUnexpectedHTTPCode(Swift.Int)
  case networkServerLimited(Swift.Int)
  case networkServerRejected(Swift.Int)
  case networkUnknown(any Swift.Error)
  case networkInvalidData
  case jsonUnableToSerialize(any Swift.Error)
  case jsonUnableToDeserialize(any Swift.Error)
  case jsonUnknown(any Swift.Error)
  case pluginError(any Swift.Error)
  case enrichmentError(Swift.String)
}
extension Segment.Analytics {
  public func reportInternalError(_ error: any Swift.Error, fatal: Swift.Bool = false)
  public static func reportInternalError(_ error: any Swift.Error, fatal: Swift.Bool = false)
}
extension Segment.Analytics {
  public func track<P>(name: Swift.String, properties: P?) where P : Swift.Decodable, P : Swift.Encodable
  public func track(name: Swift.String)
  public func identify<T>(userId: Swift.String, traits: T?) where T : Swift.Decodable, T : Swift.Encodable
  public func identify<T>(traits: T) where T : Swift.Decodable, T : Swift.Encodable
  public func identify(userId: Swift.String)
  public func screen<P>(title: Swift.String, category: Swift.String? = nil, properties: P?) where P : Swift.Decodable, P : Swift.Encodable
  public func screen(title: Swift.String, category: Swift.String? = nil)
  public func group<T>(groupId: Swift.String, traits: T?) where T : Swift.Decodable, T : Swift.Encodable
  public func group(groupId: Swift.String)
  public func alias(newId: Swift.String)
}
extension Segment.Analytics {
  public func track(name: Swift.String, properties: [Swift.String : Any]? = nil)
  public func identify(userId: Swift.String, traits: [Swift.String : Any]? = nil)
  public func screen(title: Swift.String, category: Swift.String? = nil, properties: [Swift.String : Any]? = nil)
  public func group(groupId: Swift.String, traits: [Swift.String : Any]?)
}
extension Segment.Analytics {
  public func track<P>(name: Swift.String, properties: P?, enrichments: [Segment.EnrichmentClosure]?) where P : Swift.Decodable, P : Swift.Encodable
  public func track(name: Swift.String, enrichments: [Segment.EnrichmentClosure]?)
  public func track(name: Swift.String, properties: [Swift.String : Any]?, enrichments: [Segment.EnrichmentClosure]?)
  public func identify<T>(userId: Swift.String, traits: T?, enrichments: [Segment.EnrichmentClosure]?) where T : Swift.Decodable, T : Swift.Encodable
  public func identify<T>(traits: T, enrichments: [Segment.EnrichmentClosure]?) where T : Swift.Decodable, T : Swift.Encodable
  public func identify(userId: Swift.String, enrichments: [Segment.EnrichmentClosure]?)
  public func identify(userId: Swift.String, traits: [Swift.String : Any]? = nil, enrichments: [Segment.EnrichmentClosure]?)
  public func screen<P>(title: Swift.String, category: Swift.String? = nil, properties: P?, enrichments: [Segment.EnrichmentClosure]?) where P : Swift.Decodable, P : Swift.Encodable
  public func screen(title: Swift.String, category: Swift.String? = nil, enrichments: [Segment.EnrichmentClosure]?)
  public func screen(title: Swift.String, category: Swift.String? = nil, properties: [Swift.String : Any]?, enrichments: [Segment.EnrichmentClosure]?)
  public func group<T>(groupId: Swift.String, traits: T?, enrichments: [Segment.EnrichmentClosure]?) where T : Swift.Decodable, T : Swift.Encodable
  public func group(groupId: Swift.String, enrichments: [Segment.EnrichmentClosure]?)
  public func group(groupId: Swift.String, traits: [Swift.String : Any]?, enrichments: [Segment.EnrichmentClosure]?)
  public func alias(newId: Swift.String, enrichments: [Segment.EnrichmentClosure]?)
}
@objc(SEGAnalytics) public class ObjCAnalytics : ObjectiveC.NSObject {
  final public let analytics: Segment.Analytics
  @objc public init(configuration: Segment.ObjCConfiguration)
  public init(wrapping analytics: Segment.Analytics)
  @objc deinit
}
@objc extension Segment.ObjCAnalytics {
  @objc(track:) dynamic public func track(name: Swift.String)
  @objc(track:properties:) dynamic public func track(name: Swift.String, properties: [Swift.String : Any]?)
  @objc(identify:) dynamic public func identify(userId: Swift.String)
  @objc(identify:traits:) dynamic public func identify(userId: Swift.String?, traits: [Swift.String : Any]?)
  @objc(screen:) dynamic public func screen(title: Swift.String)
  @objc(screen:category:) dynamic public func screen(title: Swift.String, category: Swift.String?)
  @objc(screen:category:properties:) dynamic public func screen(title: Swift.String, category: Swift.String?, properties: [Swift.String : Any]?)
  @objc(group:) dynamic public func group(groupId: Swift.String)
  @objc(group:traits:) dynamic public func group(groupId: Swift.String, traits: [Swift.String : Any]?)
  @objc(alias:) dynamic public func alias(newId: Swift.String)
}
@objc extension Segment.ObjCAnalytics {
  @objc dynamic public var anonymousId: Swift.String {
    @objc get
  }
  @objc dynamic public var userId: Swift.String? {
    @objc get
  }
  @objc dynamic public func traits() -> [Swift.String : Any]?
  @objc dynamic public func flush()
  @objc dynamic public func reset()
  @objc dynamic public func settings() -> [Swift.String : Any]?
  @objc dynamic public func openURL(_ url: Foundation.URL, options: [Swift.String : Any] = [:])
  @objc dynamic public func version() -> Swift.String
}
@objc(SEGConfiguration) public class ObjCConfiguration : ObjectiveC.NSObject {
  @objc public var application: Any? {
    @objc get
    @objc set(value)
  }
  @objc public var trackApplicationLifecycleEvents: Swift.Bool {
    @objc get
    @objc set(value)
  }
  @objc public var flushAt: Swift.Int {
    @objc get
    @objc set(value)
  }
  @objc public var flushInterval: Foundation.TimeInterval {
    @objc get
    @objc set(value)
  }
  @objc public var defaultSettings: [Swift.String : Any] {
    @objc get
    @objc set(value)
  }
  @objc public var autoAddSegmentDestination: Swift.Bool {
    @objc get
    @objc set(value)
  }
  @objc public var apiHost: Swift.String {
    @objc get
    @objc set(value)
  }
  @objc public var cdnHost: Swift.String {
    @objc get
    @objc set(value)
  }
  @objc public var requestFactory: ((Foundation.URLRequest) -> Foundation.URLRequest)? {
    @objc get
    @objc set(value)
  }
  @objc public init(writeKey: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(SEGDestinationMetadata) public class ObjCDestinationMetadata : ObjectiveC.NSObject {
  public var bundled: [Swift.String] {
    get
    set(v)
  }
  public var unbundled: [Swift.String] {
    get
    set(v)
  }
  public var bundledIds: [Swift.String] {
    get
    set(v)
  }
  @objc deinit
}
@objc(SEGRawEvent) public protocol ObjCRawEvent : ObjectiveC.NSObjectProtocol {
  @objc var type: Swift.String? { get }
  @objc var messageId: Swift.String? { get }
  @objc var timestamp: Swift.String? { get }
  @objc var anonymousId: Swift.String? { get set }
  @objc var userId: Swift.String? { get set }
  @objc var context: [Swift.String : Any]? { get set }
  @objc var integrations: [Swift.String : Any]? { get set }
  @objc var metadata: Segment.ObjCDestinationMetadata? { get set }
}
@_hasMissingDesignatedInitializers @objc(SEGTrackEvent) public class ObjCTrackEvent : ObjectiveC.NSObject, Segment.ObjCRawEvent {
  @objc public var type: Swift.String? {
    @objc get
  }
  @objc public var messageId: Swift.String? {
    @objc get
  }
  @objc public var timestamp: Swift.String? {
    @objc get
  }
  @objc public var anonymousId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var userId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var context: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var integrations: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var metadata: Segment.ObjCDestinationMetadata? {
    @objc get
    @objc set(v)
  }
  @objc public var event: Swift.String {
    @objc get
    @objc set(v)
  }
  @objc public var properties: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public init(name: Swift.String, properties: [Swift.String : Any]? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(SEGIdentifyEvent) public class ObjCIdentifyEvent : ObjectiveC.NSObject, Segment.ObjCRawEvent {
  @objc public var type: Swift.String? {
    @objc get
  }
  @objc public var messageId: Swift.String? {
    @objc get
  }
  @objc public var timestamp: Swift.String? {
    @objc get
  }
  @objc public var anonymousId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var userId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var context: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var integrations: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var metadata: Segment.ObjCDestinationMetadata? {
    @objc get
    @objc set(v)
  }
  @objc public var traits: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public init(userId: Swift.String, traits: [Swift.String : Any]? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(SEGScreenEvent) public class ObjCScreenEvent : ObjectiveC.NSObject, Segment.ObjCRawEvent {
  @objc public var type: Swift.String? {
    @objc get
  }
  @objc public var messageId: Swift.String? {
    @objc get
  }
  @objc public var timestamp: Swift.String? {
    @objc get
  }
  @objc public var anonymousId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var userId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var context: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var integrations: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var metadata: Segment.ObjCDestinationMetadata? {
    @objc get
    @objc set(v)
  }
  @objc public var name: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var category: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var properties: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public init(name: Swift.String, category: Swift.String?, properties: [Swift.String : Any]? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(SEGGroupEvent) public class ObjCGroupEvent : ObjectiveC.NSObject, Segment.ObjCRawEvent {
  @objc public var type: Swift.String? {
    @objc get
  }
  @objc public var messageId: Swift.String? {
    @objc get
  }
  @objc public var timestamp: Swift.String? {
    @objc get
  }
  @objc public var anonymousId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var userId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var context: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var integrations: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var metadata: Segment.ObjCDestinationMetadata? {
    @objc get
    @objc set(v)
  }
  @objc public var groupId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var traits: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public init(groupId: Swift.String?, traits: [Swift.String : Any]? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(SEGAliasEvent) public class ObjCAliasEvent : ObjectiveC.NSObject, Segment.ObjCRawEvent {
  @objc public var type: Swift.String? {
    @objc get
  }
  @objc public var messageId: Swift.String? {
    @objc get
  }
  @objc public var timestamp: Swift.String? {
    @objc get
  }
  @objc public var anonymousId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var userId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public var context: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var integrations: [Swift.String : Any]? {
    @objc get
    @objc set(v)
  }
  @objc public var metadata: Segment.ObjCDestinationMetadata? {
    @objc get
    @objc set(v)
  }
  @objc public var previousId: Swift.String? {
    @objc get
    @objc set(v)
  }
  @objc public init(newId: Swift.String?)
  @objc deinit
}
@objc(SEGPlugin) public protocol ObjCPlugin {
}
public protocol ObjCPluginShim {
  func instance() -> any Segment.EventPlugin
}
@_inheritsConvenienceInitializers @objc(SEGEventPlugin) public class ObjCEventPlugin : ObjectiveC.NSObject, Segment.EventPlugin, Segment.ObjCPlugin {
  public var type: Segment.PluginType
  weak public var analytics: Segment.Analytics?
  @objc(executeEvent:) public func execute(event: (any Segment.ObjCRawEvent)?) -> (any Segment.ObjCRawEvent)?
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  @objc override dynamic public init()
  @objc deinit
}
@objc(SEGBlockPlugin) public class ObjCBlockPlugin : Segment.ObjCEventPlugin {
  @objc(executeEvent:) override public func execute(event: (any Segment.ObjCRawEvent)?) -> (any Segment.ObjCRawEvent)?
  @objc(initWithBlock:) public init(block: @escaping ((any Segment.ObjCRawEvent)?) -> (any Segment.ObjCRawEvent)?)
  @objc deinit
}
@objc extension Segment.ObjCAnalytics {
  @objc(addPlugin:) dynamic public func add(plugin: (any Segment.ObjCPlugin)?)
  @objc(addPlugin:destinationKey:) dynamic public func add(plugin: (any Segment.ObjCPlugin)?, destinationKey: Swift.String)
}
public enum PluginType : Swift.Int, Swift.CaseIterable {
  case before
  case enrichment
  case destination
  case after
  case utility
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [Segment.PluginType]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [Segment.PluginType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public enum UpdateType {
  case initial
  case refresh
  public static func == (a: Segment.UpdateType, b: Segment.UpdateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Plugin : AnyObject {
  var type: Segment.PluginType { get }
  var analytics: Segment.Analytics? { get set }
  func configure(analytics: Segment.Analytics)
  func update(settings: Segment.Settings, type: Segment.UpdateType)
  func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  func shutdown()
}
public protocol EventPlugin : Segment.Plugin {
  func identify(event: Segment.IdentifyEvent) -> Segment.IdentifyEvent?
  func track(event: Segment.TrackEvent) -> Segment.TrackEvent?
  func group(event: Segment.GroupEvent) -> Segment.GroupEvent?
  func alias(event: Segment.AliasEvent) -> Segment.AliasEvent?
  func screen(event: Segment.ScreenEvent) -> Segment.ScreenEvent?
  func reset()
  func flush()
}
public protocol DestinationPlugin : Segment.EventPlugin {
  var key: Swift.String { get }
  var timeline: Segment.Timeline { get }
  func add(plugin: any Segment.Plugin) -> any Segment.Plugin
  func apply(closure: (any Segment.Plugin) -> Swift.Void)
  func remove(plugin: any Segment.Plugin)
}
public protocol UtilityPlugin : Segment.EventPlugin {
}
public protocol VersionedPlugin {
  static func version() -> Swift.String
}
public protocol FlushCompletion {
  func flush(group: Dispatch.DispatchGroup)
}
public typealias EnrichmentClosure = (_ event: (any Segment.RawEvent)?) -> (any Segment.RawEvent)?
@_hasMissingDesignatedInitializers public class ClosureEnrichment : Segment.Plugin {
  public var type: Segment.PluginType
  weak public var analytics: Segment.Analytics?
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  @objc deinit
}
extension Segment.Plugin {
  public func configure(analytics: Segment.Analytics)
}
extension Segment.DestinationPlugin {
  public func configure(analytics: Segment.Analytics)
  public func apply(closure: (any Segment.Plugin) -> Swift.Void)
  @discardableResult
  public func add(plugin: any Segment.Plugin) -> any Segment.Plugin
  @discardableResult
  public func add(enrichment: @escaping Segment.EnrichmentClosure) -> any Segment.Plugin
  public func remove(plugin: any Segment.Plugin)
  public func find<T>(pluginType: T.Type) -> T? where T : Segment.Plugin
  public func findAll<T>(pluginType: T.Type) -> [T]? where T : Segment.Plugin
}
extension Segment.Analytics {
  public func apply(closure: (any Segment.Plugin) -> Swift.Void)
  @discardableResult
  public func add(plugin: any Segment.Plugin) -> any Segment.Plugin
  @discardableResult
  public func add(enrichment: @escaping Segment.EnrichmentClosure) -> any Segment.Plugin
  public func remove(plugin: any Segment.Plugin)
  public func find<T>(pluginType: T.Type) -> T? where T : Segment.Plugin
  public func findAll<T>(pluginType: T.Type) -> [T]? where T : Segment.Plugin
  public func find(key: Swift.String) -> (any Segment.DestinationPlugin)?
}
public protocol OpeningURLs {
  func openURL(_ url: Foundation.URL, options: [Swift.String : Any])
}
@_hasMissingDesignatedInitializers public class Context {
  final public let type: Segment.PluginType
  weak public var analytics: Segment.Analytics?
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  public static func insertOrigin(event: (any Segment.RawEvent)?, data: [Swift.String : Any]) -> (any Segment.RawEvent)?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DestinationMetadataPlugin : Segment.Plugin {
  final public let type: Segment.PluginType
  weak public var analytics: Segment.Analytics?
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  @objc deinit
}
public class DeviceToken {
  final public let type: Segment.PluginType
  weak public var analytics: Segment.Analytics?
  public var token: Swift.String?
  required public init()
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  @objc deinit
}
extension Segment.Analytics {
  public func setDeviceToken(_ token: Swift.String)
}
public protocol macOSLifecycle {
  func applicationDidResignActive()
  func application(didFinishLaunchingWithOptions launchOptions: [Swift.String : Any]?)
  func applicationWillBecomeActive()
  func applicationDidBecomeActive()
  func applicationWillHide()
  func applicationDidHide()
  func applicationDidUnhide()
  func applicationDidUpdate()
  func applicationWillFinishLaunching()
  func applicationWillResignActive()
  func applicationWillUnhide()
  func applicationWillUpdate()
  func applicationWillTerminate()
  func applicationDidChangeScreenParameters()
}
extension Segment.macOSLifecycle {
  public func applicationDidResignActive()
  public func application(didFinishLaunchingWithOptions launchOptions: [Swift.String : Any]?)
  public func applicationWillBecomeActive()
  public func applicationDidBecomeActive()
  public func applicationWillHide()
  public func applicationDidHide()
  public func applicationDidUnhide()
  public func applicationDidUpdate()
  public func applicationWillFinishLaunching()
  public func applicationWillResignActive()
  public func applicationWillUnhide()
  public func applicationWillUpdate()
  public func applicationWillTerminate()
  public func applicationDidChangeScreenParameters()
}
extension Segment.SegmentDestination : Segment.macOSLifecycle {
  public func applicationDidBecomeActive()
  public func applicationWillResignActive()
}
extension Segment.IntervalBasedFlushPolicy : Segment.macOSLifecycle {
  public func applicationWillEnterForeground()
  public func applicationDidEnterBackground()
}
@_hasMissingDesignatedInitializers public class SegmentAnonymousId : Segment.AnonymousIdGenerator {
  public func newAnonymousId() -> Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class SegmentDestination : Segment.DestinationPlugin, Sovran.Subscriber, Segment.FlushCompletion {
  final public let type: Segment.PluginType
  final public let key: Swift.String
  final public let timeline: Segment.Timeline
  weak public var analytics: Segment.Analytics? {
    get
    set
  }
  public func update(settings: Segment.Settings, type: Segment.UpdateType)
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  public func flush()
  public func flush(group: Dispatch.DispatchGroup)
  @objc deinit
}
extension Segment.SegmentDestination : Segment.VersionedPlugin {
  public static func version() -> Swift.String
}
@_hasMissingDesignatedInitializers public class StartupQueue : Segment.Plugin, Sovran.Subscriber {
  @Segment.Atomic public var running: Swift.Bool {
    get
  }
  final public let type: Segment.PluginType
  weak public var analytics: Segment.Analytics? {
    get
    set
  }
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  @objc deinit
}
public struct Settings : Swift.Codable {
  public var integrations: Segment.JSON?
  public var plan: Segment.JSON?
  public var edgeFunction: Segment.JSON?
  public var middlewareSettings: Segment.JSON?
  public var metrics: Segment.JSON?
  public var consentSettings: Segment.JSON?
  public init(writeKey: Swift.String, apiHost: Swift.String)
  public init(writeKey: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public static func load(from url: Foundation.URL?) -> Segment.Settings?
  public static func load(resource: Swift.String, bundle: Foundation.Bundle = Bundle.main) -> Segment.Settings?
  public func integrationSettings(forKey key: Swift.String) -> [Swift.String : Any]?
  public func integrationSettings<T>(forKey key: Swift.String) -> T? where T : Swift.Decodable, T : Swift.Encodable
  public func integrationSettings<T>(forPlugin plugin: any Segment.DestinationPlugin) -> T? where T : Swift.Decodable, T : Swift.Encodable
  public func hasIntegrationSettings(forPlugin plugin: any Segment.DestinationPlugin) -> Swift.Bool
  public func hasIntegrationSettings(key: Swift.String) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Segment.Settings : Swift.Equatable {
  public static func == (lhs: Segment.Settings, rhs: Segment.Settings) -> Swift.Bool
}
extension Segment.Analytics : Sovran.Subscriber {
}
public class Timeline {
  public init()
  @objc deinit
}
extension Segment.Plugin {
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  public func update(settings: Segment.Settings, type: Segment.UpdateType)
  public func shutdown()
}
extension Segment.EventPlugin {
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
  public func identify(event: Segment.IdentifyEvent) -> Segment.IdentifyEvent?
  public func track(event: Segment.TrackEvent) -> Segment.TrackEvent?
  public func screen(event: Segment.ScreenEvent) -> Segment.ScreenEvent?
  public func group(event: Segment.GroupEvent) -> Segment.GroupEvent?
  public func alias(event: Segment.AliasEvent) -> Segment.AliasEvent?
  public func flush()
  public func reset()
}
extension Segment.DestinationPlugin {
  public func execute<T>(event: T?) -> T? where T : Segment.RawEvent
}
public struct DestinationMetadata : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol RawEvent : Swift.Decodable, Swift.Encodable {
  var type: Swift.String? { get set }
  var anonymousId: Swift.String? { get set }
  var messageId: Swift.String? { get set }
  var userId: Swift.String? { get set }
  var timestamp: Swift.String? { get set }
  var context: Segment.JSON? { get set }
  var integrations: Segment.JSON? { get set }
  var metrics: [Segment.JSON]? { get set }
  var _metadata: Segment.DestinationMetadata? { get set }
}
public struct TrackEvent : Segment.RawEvent {
  public var type: Swift.String?
  public var anonymousId: Swift.String?
  public var messageId: Swift.String?
  public var userId: Swift.String?
  public var timestamp: Swift.String?
  public var context: Segment.JSON?
  public var integrations: Segment.JSON?
  public var metrics: [Segment.JSON]?
  public var _metadata: Segment.DestinationMetadata?
  public var event: Swift.String
  public var properties: Segment.JSON?
  public init(event: Swift.String, properties: Segment.JSON?)
  public init(existing: Segment.TrackEvent)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct IdentifyEvent : Segment.RawEvent {
  public var type: Swift.String?
  public var anonymousId: Swift.String?
  public var messageId: Swift.String?
  public var userId: Swift.String?
  public var timestamp: Swift.String?
  public var context: Segment.JSON?
  public var integrations: Segment.JSON?
  public var metrics: [Segment.JSON]?
  public var _metadata: Segment.DestinationMetadata?
  public var traits: Segment.JSON?
  public init(userId: Swift.String? = nil, traits: Segment.JSON? = nil)
  public init(existing: Segment.IdentifyEvent)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ScreenEvent : Segment.RawEvent {
  public var type: Swift.String?
  public var anonymousId: Swift.String?
  public var messageId: Swift.String?
  public var userId: Swift.String?
  public var timestamp: Swift.String?
  public var context: Segment.JSON?
  public var integrations: Segment.JSON?
  public var metrics: [Segment.JSON]?
  public var _metadata: Segment.DestinationMetadata?
  public var name: Swift.String?
  public var category: Swift.String?
  public var properties: Segment.JSON?
  public init(title: Swift.String? = nil, category: Swift.String?, properties: Segment.JSON? = nil)
  public init(existing: Segment.ScreenEvent)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GroupEvent : Segment.RawEvent {
  public var type: Swift.String?
  public var anonymousId: Swift.String?
  public var messageId: Swift.String?
  public var userId: Swift.String?
  public var timestamp: Swift.String?
  public var context: Segment.JSON?
  public var integrations: Segment.JSON?
  public var metrics: [Segment.JSON]?
  public var _metadata: Segment.DestinationMetadata?
  public var groupId: Swift.String?
  public var traits: Segment.JSON?
  public init(groupId: Swift.String? = nil, traits: Segment.JSON? = nil)
  public init(existing: Segment.GroupEvent)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AliasEvent : Segment.RawEvent {
  public var type: Swift.String?
  public var anonymousId: Swift.String?
  public var messageId: Swift.String?
  public var timestamp: Swift.String?
  public var context: Segment.JSON?
  public var integrations: Segment.JSON?
  public var metrics: [Segment.JSON]?
  public var _metadata: Segment.DestinationMetadata?
  public var userId: Swift.String?
  public var previousId: Swift.String?
  public init(newId: Swift.String?, previousId: Swift.String? = nil)
  public init(existing: Segment.AliasEvent)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Segment.RawEvent {
  public mutating func disableCloudIntegrations(exceptKeys: [Swift.String]? = nil)
  public mutating func enableCloudIntegrations(exceptKeys: [Swift.String]? = nil)
  public mutating func disableIntegration(key: Swift.String)
  public mutating func enableIntegration(key: Swift.String)
}
@propertyWrapper public class Atomic<T> {
  public init(wrappedValue value: T)
  @objc deinit
  public var wrappedValue: T {
    get
  }
  public func set(_ newValue: T)
  public func mutate(_ mutation: (inout T) -> Swift.Void)
}
public enum JSON : Swift.Equatable {
  case null
  case bool(Swift.Bool)
  case number(Foundation.Decimal)
  case string(Swift.String)
  case array([Segment.JSON])
  case object([Swift.String : Segment.JSON])
  public init(_ object: [Swift.String : Any]) throws
  public init?(nilOrObject object: [Swift.String : Any]?) throws
  public init<T>(with value: T) throws where T : Swift.Decodable, T : Swift.Encodable
  public init(_ value: Any) throws
  public static func == (a: Segment.JSON, b: Segment.JSON) -> Swift.Bool
}
extension Segment.JSON : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Encodable {
  public func prettyPrint() -> Swift.String
  public func toString() -> Swift.String
  public func toString(pretty: Swift.Bool) -> Swift.String
}
extension Segment.JSON {
  public func codableValue<T>() -> T? where T : Swift.Decodable, T : Swift.Encodable
  public var boolValue: Swift.Bool? {
    get
  }
  public var decimalValue: Foundation.Decimal? {
    get
  }
  public var intValue: Swift.Int? {
    get
  }
  public var uintValue: Swift.UInt? {
    get
  }
  public var floatValue: Swift.Float? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public var arrayValue: [Any]? {
    get
  }
  public var dictionaryValue: [Swift.String : Any]? {
    get
  }
}
extension Segment.JSON {
  public func mapTransform(_ keys: [Swift.String : Swift.String], valueTransform: ((_ key: Swift.String, _ value: Any) -> Any)? = nil) throws -> Segment.JSON
  public func add(value: Any) throws -> Segment.JSON?
  public func add(value: Any, forKey key: Swift.String) throws -> Segment.JSON?
  public func remove(key: Swift.String) throws -> Segment.JSON?
  public subscript(index: Swift.Int) -> Segment.JSON? {
    get
  }
  public subscript(key: Swift.String) -> Segment.JSON? {
    get
  }
  public subscript<T>(keyPath keyPath: Segment.KeyPath) -> T? where T : Swift.Decodable, T : Swift.Encodable {
    get
    set(newValue)
  }
  public func value<T>(forKeyPath keyPath: Segment.KeyPath) -> T? where T : Swift.Decodable, T : Swift.Encodable
  public mutating func setValue<T>(_ value: T?, forKeyPath keyPath: Segment.KeyPath) where T : Swift.Decodable, T : Swift.Encodable
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  public func mapTransform(_ keys: [Swift.String : Swift.String], valueTransform: ((_ key: Key, _ value: Value) -> Any)? = nil) throws -> [Key : Value]
}
public struct BasicHandler {
}
public struct KeyPath {
  public init(_ string: Swift.String)
}
extension Segment.KeyPath : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public init(unicodeScalarLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Swift.Dictionary where Key : Swift.StringProtocol {
  public subscript(keyPath keyPath: Segment.KeyPath) -> Any? {
    get
    set
  }
  public subscript(keyPath keyPath: Segment.KeyPath, reference reference: Any?) -> Any? {
    get
    set
  }
  public func exists(keyPath: Segment.KeyPath, reference: Any? = nil) -> Swift.Bool
}
extension Segment.Analytics {
  public func log(message: Swift.String)
}
public enum HTTPClientErrors : Swift.Error {
  case badSession
  case failedToOpenBatch
  case statusCode(code: Swift.Int)
  case unknown(error: any Swift.Error)
}
@_hasMissingDesignatedInitializers public class HTTPClient {
  @objc deinit
}
extension Foundation.URLSessionDataTask : Segment.DataTask {
}
extension Foundation.URLSessionUploadTask : Segment.UploadTask {
}
extension Foundation.URLSession : Segment.HTTPSession {
  @available(macOS 10.9, *)
  public typealias DataTaskType = Foundation.URLSessionDataTask
  @available(macOS 10.9, *)
  public typealias UploadTaskType = Foundation.URLSessionUploadTask
}
public protocol DataTask {
  var state: Foundation.URLSessionTask.State { get }
  func resume()
}
public protocol UploadTask : Segment.DataTask {
}
public enum HTTPSessions {
  public static func urlSession() -> any Segment.HTTPSession
}
public protocol HTTPSession {
  associatedtype DataTaskType : Segment.DataTask
  associatedtype UploadTaskType : Segment.UploadTask
  func uploadTask(with request: Foundation.URLRequest, fromFile file: Foundation.URL, completionHandler: @escaping @Sendable (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> Self.UploadTaskType
  func uploadTask(with request: Foundation.URLRequest, from bodyData: Foundation.Data?, completionHandler: @escaping @Sendable (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> Self.UploadTaskType
  func dataTask(with request: Foundation.URLRequest, completionHandler: @escaping @Sendable (Foundation.Data?, Foundation.URLResponse?, (any Swift.Error)?) -> Swift.Void) -> Self.DataTaskType
  func finishTasksAndInvalidate()
}
public class CountBasedFlushPolicy : Segment.FlushPolicy {
  weak public var analytics: Segment.Analytics?
  public init()
  public init(count: Swift.Int)
  public func configure(analytics: Segment.Analytics)
  public func shouldFlush() -> Swift.Bool
  public func updateState(event: any Segment.RawEvent)
  public func reset()
  @objc deinit
}
public protocol FlushPolicy : AnyObject {
  var analytics: Segment.Analytics? { get set }
  func configure(analytics: Segment.Analytics)
  func shouldFlush() -> Swift.Bool
  func updateState(event: any Segment.RawEvent)
  func reset()
}
extension Segment.Analytics {
  public func add(flushPolicy: any Segment.FlushPolicy)
  public func remove(flushPolicy: any Segment.FlushPolicy)
  public func remove<T>(flushPolicy: T.Type) where T : Segment.FlushPolicy
  public func removeAllFlushPolicies()
  public func find<T>(flushPolicy: T.Type) -> (any Segment.FlushPolicy)? where T : Segment.FlushPolicy
}
public class IntervalBasedFlushPolicy : Segment.FlushPolicy, Sovran.Subscriber {
  weak public var analytics: Segment.Analytics?
  public init()
  public init(interval: Foundation.TimeInterval)
  @objc deinit
  public func configure(analytics: Segment.Analytics)
  public func shouldFlush() -> Swift.Bool
  public func updateState(event: any Segment.RawEvent)
  public func reset()
}
public struct DataResult {
  public let data: Foundation.Data?
  public let dataFiles: [Foundation.URL]?
  public let removable: [any Swift.Equatable]?
  public init(data: Foundation.Data?, removable: [any Swift.Equatable]?)
  public init(dataFiles: [Foundation.URL]?, removable: [any Swift.Equatable]?)
}
public enum DataTransactionType {
  case data
  case file
  public static func == (a: Segment.DataTransactionType, b: Segment.DataTransactionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DataStore {
  typealias ItemID = any Swift.Equatable
  associatedtype StoreConfiguration
  var hasData: Swift.Bool { get }
  var count: Swift.Int { get }
  var transactionType: Segment.DataTransactionType { get }
  init(configuration: Self.StoreConfiguration)
  func reset()
  func append(data: any Segment.RawEvent)
  func fetch(count: Swift.Int?, maxBytes: Swift.Int?) -> Segment.DataResult?
  func remove(data: [Self.ItemID])
}
public class TransientDB {
  public var hasData: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var transactionType: Segment.DataTransactionType {
    get
  }
  public init(store: any Segment.DataStore, asyncAppend: Swift.Bool = true)
  public func reset()
  public func append(data: any Segment.RawEvent)
  public func fetch(count: Swift.Int? = nil, maxBytes: Swift.Int? = nil) -> Segment.DataResult?
  public func remove(data: [any Swift.Equatable])
  @objc deinit
}
public class DirectoryStore : Segment.DataStore {
  public typealias StoreConfiguration = Segment.DirectoryStore.Configuration
  public struct Configuration {
    public init(writeKey: Swift.String, storageLocation: Foundation.URL, baseFilename: Swift.String, maxFileSize: Swift.Int, indexKey: Swift.String)
  }
  public var hasData: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var transactionType: Segment.DataTransactionType {
    get
  }
  required public init(configuration: Segment.DirectoryStore.Configuration)
  public func reset()
  public func append(data: any Segment.RawEvent)
  public func fetch(count: Swift.Int?, maxBytes: Swift.Int?) -> Segment.DataResult?
  public func remove(data: [any Swift.Equatable])
  @objc deinit
}
public class MemoryStore : Segment.DataStore {
  public typealias StoreConfiguration = Segment.MemoryStore.Configuration
  public struct Configuration {
    public init(writeKey: Swift.String, maxItems: Swift.Int, maxFetchSize: Swift.Int)
  }
  public var hasData: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var transactionType: Segment.DataTransactionType {
    get
  }
  required public init(configuration: Segment.MemoryStore.Configuration)
  public func reset()
  public func append(data: any Segment.RawEvent)
  public func fetch(count: Swift.Int?, maxBytes: Swift.Int?) -> Segment.DataResult?
  public func remove(data: [any Swift.Equatable])
  @objc deinit
}
extension Segment.OperatingMode : Swift.Equatable {}
extension Segment.OperatingMode : Swift.Hashable {}
extension Segment.PluginType : Swift.Equatable {}
extension Segment.PluginType : Swift.Hashable {}
extension Segment.PluginType : Swift.RawRepresentable {}
extension Segment.UpdateType : Swift.Equatable {}
extension Segment.UpdateType : Swift.Hashable {}
extension Segment.Context : Segment.Plugin {}
extension Segment.DeviceToken : Segment.Plugin {}
extension Segment.DataTransactionType : Swift.Equatable {}
extension Segment.DataTransactionType : Swift.Hashable {}
